import json, os, re
from pathlib import Path

NB = {
 "cells": [
  {"cell_type":"markdown","metadata":{},"source":[
"# 03 · EDA — Cardiovascular (Enhanced)\n",
"\n",
"Interactive + weekly aggregation + consolidated Excel summary.\n",
"\n",
"**Inputs**: `features_cardiovascular.csv`, `features_daily_updated.csv`, `extract_manifest.json`, `cardio_manifest.json`\n",
"**Outputs**: PNG/HTML figures in `eda_outputs/`, JSON + Excel summaries.\n"
  ]},
  {"cell_type":"code","metadata":{},"source":[
"import os, json, re\n",
"from pathlib import Path\n",
"import pandas as pd\n",
"import numpy as np\n",
"import matplotlib.pyplot as plt\n",
"import plotly.express as px\n",
"import plotly.io as pio\n",
"from datetime import datetime\n",
"\n",
"PID = 'P000001'\n",
"SNAP = '2025-09-29'  # <- altere aqui se quiser outro snapshot\n",
"AGG = 'median'       # 'median' ou 'mean' para weekly aggregation\n",
"\n",
"SNAPDIR = Path('data_ai')/PID/'snapshots'/SNAP\n",
"OUTDIR  = SNAPDIR/'eda_outputs'\n",
"OUTDIR.mkdir(parents=True, exist_ok=True)\n",
"print('SNAPDIR =', SNAPDIR)\n",
"pio.renderers.default = 'notebook'\n"
  ]},
  {"cell_type":"markdown","metadata":{},"source":["## 01 | Read manifests (reproducibility)"]},
  {"cell_type":"code","metadata":{},"source":[
"extract_manifest = {}\n",
"cardio_manifest = {}\n",
"em = SNAPDIR/'extract_manifest.json'\n",
"cm = SNAPDIR/'cardio_manifest.json'\n",
"if em.exists(): extract_manifest = json.loads(em.read_text(encoding='utf-8'))\n",
"if cm.exists(): cardio_manifest  = json.loads(cm.read_text(encoding='utf-8'))\n",
"print('extract_manifest keys:', list(extract_manifest.keys()))\n",
"print('cardio_manifest keys:', list(cardio_manifest.keys()))\n"
  ]},
  {"cell_type":"markdown","metadata":{},"source":["## 02 | Load data & QC"]},
  {"cell_type":"code","metadata":{},"source":[
"def _read_csv(path: Path, dtcols=('date',)):\n",
"    if not path.exists(): return pd.DataFrame()\n",
"    return pd.read_csv(path, parse_dates=[c for c in dtcols if c in pd.read_csv(path, nrows=0).columns])\n",
"\n",
"feat_cardio = _read_csv(SNAPDIR/'features_cardiovascular.csv', ('date',))\n",
"feat_dailyu = _read_csv(SNAPDIR/'features_daily_updated.csv', ('date',))\n",
"\n",
"def qc_report(df: pd.DataFrame, name: str):\n",
"    if df.empty:\n",
"        return {'name': name, 'empty': True}\n",
"    cols_num = [c for c in df.columns if c!='date' and pd.api.types.is_numeric_dtype(df[c])]\n",
"    rep = {\n",
"        'name': name,\n",
"        'empty': False,\n",
"        'n_rows': int(len(df)),\n",
"        'date_min': str(df['date'].min().date()) if 'date' in df else None,\n",
"        'date_max': str(df['date'].max().date()) if 'date' in df else None,\n",
"        'n_na_total': int(df.isna().sum().sum()),\n",
"        'n_num_cols': len(cols_num)\n",
"    }\n",
"    return rep\n",
"\n",
"qc_cardio = qc_report(feat_cardio, 'features_cardiovascular')\n",
"qc_dailyu = qc_report(feat_dailyu, 'features_daily_updated')\n",
"print(qc_cardio); print(qc_dailyu)\n",
"\n",
"(SNAPDIR/'eda_outputs'/'eda_qc.json').write_text(json.dumps({'cardio': qc_cardio, 'dailyu': qc_dailyu}, indent=2), encoding='utf-8')\n"
  ]},
  {"cell_type":"markdown","metadata":{},"source":["## 03 | Temporal trends (HR / HRV) — static + interactive"]},
  {"cell_type":"code","metadata":{},"source":[
"if feat_cardio.empty:\n",
"    print('features_cardiovascular.csv is empty — skipping temporal trends')\n",
"else:\n",
"    df = feat_cardio.copy().sort_values('date')\n",
"    # heuristics to detect columns\n",
"    hr_cols  = [c for c in df.columns if re.search(r'(^|_)hr_mean(_|$)', c)]\n",
"    hrv_cols = [c for c in df.columns if re.search(r'hrv.*(sdnn|sdnn_ms).*mean', c)]\n",
"    # ---- matplotlib (static)\n",
"    if hr_cols:\n",
"        plt.figure(figsize=(11,3))\n",
"        plt.plot(df['date'], df[hr_cols[0]])\n",
"        plt.title(f'Daily HR mean — {hr_cols[0]}'); plt.xlabel('date'); plt.ylabel('bpm'); plt.tight_layout()\n",
"        plt.savefig(OUTDIR/'trend_hr_mean.png'); plt.show()\n",
"    if hrv_cols:\n",
"        plt.figure(figsize=(11,3))\n",
"        plt.plot(df['date'], df[hrv_cols[0]])\n",
"        plt.title(f'Daily HRV (SDNN) mean — {hrv_cols[0]}'); plt.xlabel('date'); plt.ylabel('ms'); plt.tight_layout()\n",
"        plt.savefig(OUTDIR/'trend_hrv_sdnn_mean.png'); plt.show()\n",
"    # ---- plotly (interactive)\n",
"    if hr_cols:\n",
"        fig = px.line(df, x='date', y=hr_cols[0], title=f'HR mean (interactive) — {hr_cols[0]}')\n",
"        fig.write_html(str(OUTDIR/'trend_hr_mean.html'))\n",
"        fig.show()\n",
"    if hrv_cols:\n",
"        fig = px.line(df, x='date', y=hrv_cols[0], title=f'HRV SDNN mean (interactive) — {hrv_cols[0]}')\n",
"        fig.write_html(str(OUTDIR/'trend_hrv_sdnn_mean.html'))\n",
"        fig.show()\n"
  ]},
  {"cell_type":"markdown","metadata":{},"source":["## 04 | Weekly aggregation (median/mean)"]},
  {"cell_type":"code","metadata":{},"source":[
"weekly = pd.DataFrame()\n",
"if not feat_cardio.empty:\n",
"    df = feat_cardio.copy().set_index('date').sort_index()\n",
"    num_cols = [c for c in df.columns if pd.api.types.is_numeric_dtype(df[c])]\n",
"    aggfn = np.median if AGG=='median' else np.mean\n",
"    weekly = df[num_cols].resample('W').apply(aggfn)\n",
"    weekly.index.name = 'week'\n",
"    weekly.to_csv(OUTDIR/'weekly_cardio.csv')\n",
"    display(weekly.head())\n",
"    # interactive pair: HR vs HRV weekly\n",
"    hr_cols  = [c for c in weekly.columns if re.search(r'(^|_)hr_mean(_|$)', c)]\n",
"    hrv_cols = [c for c in weekly.columns if re.search(r'hrv.*(sdnn|sdnn_ms).*mean', c)]\n",
"    if hr_cols and hrv_cols:\n",
"        wdf = weekly.reset_index()\n",
"        fig = px.scatter(wdf, x=hr_cols[0], y=hrv_cols[0], trendline='ols', title=f'Weekly {AGG}: HR vs HRV')\n",
"        fig.write_html(str(OUTDIR/'weekly_hr_vs_hrv.html'))\n",
"        fig.show()\n"
  ]},
  {"cell_type":"markdown","metadata":{},"source":["## 05 | Correlations (daily + weekly)"]},
  {"cell_type":"code","metadata":{},"source":[
"def corr_plot(df: pd.DataFrame, title: str, outpng: Path):\n",
"    if df.empty: return\n",
"    corr = df.corr(method='spearman')\n",
"    plt.figure(figsize=(7,6))\n",
"    plt.imshow(corr.values, aspect='auto')\n",
"    plt.xticks(range(len(corr.columns)), corr.columns, rotation=90)\n",
"    plt.yticks(range(len(corr.index)), corr.index)\n",
"    plt.colorbar(); plt.title(title); plt.tight_layout(); plt.savefig(outpng); plt.show()\n",
"\n",
"if not feat_cardio.empty:\n",
"    dfnum = feat_cardio.drop(columns=['date']).select_dtypes(include=[np.number])\n",
"    corr_plot(dfnum, 'Spearman correlation (daily cardio)', OUTDIR/'corr_daily.png')\n",
"if not weekly.empty:\n",
"    corr_plot(weekly, 'Spearman correlation (weekly cardio)', OUTDIR/'corr_weekly.png')\n",
"\n",
"# plotly interactive corr (daily)\n",
"if not feat_cardio.empty:\n",
"    dfnum = feat_cardio.drop(columns=['date']).select_dtypes(include=[np.number])\n",
"    corr = dfnum.corr(method='spearman')\n",
"    fig = px.imshow(corr, aspect='auto', title='Spearman correlation (daily cardio, interactive)')\n",
"    fig.write_html(str(OUTDIR/'corr_daily.html'))\n",
"    fig.show()\n"
  ]},
  {"cell_type":"markdown","metadata":{},"source":["## 06 | Segment analysis (S1–S6)"]},
  {"cell_type":"code","metadata":{},"source":[
"seg_stats = pd.DataFrame()\n",
"if not feat_cardio.empty and 'segment_id' in feat_cardio.columns:\n",
"    seg_counts = feat_cardio['segment_id'].value_counts(dropna=False).sort_index()\n",
"    print('segment counts:\\n', seg_counts)\n",
"    seg_counts.to_csv(OUTDIR/'segments_counts.csv')\n",
"    # primeira métrica de HR para boxplot\n",
"    hrcols = [c for c in feat_cardio.columns if re.search(r'(^|_)hr_mean(_|$)', c)]\n",
"    if hrcols:\n",
"        data = [feat_cardio.loc[feat_cardio['segment_id']==sid, hrcols[0]].dropna().values for sid in sorted(feat_cardio['segment_id'].dropna().unique())]\n",
"        plt.figure(figsize=(8,3))\n",
"        plt.boxplot(data)\n",
"        plt.title(f'HR mean by segment ({hrcols[0]})'); plt.tight_layout(); plt.savefig(OUTDIR/'box_hr_by_segment.png'); plt.show()\n",
"    # estatísticas agregadas por segmento\n",
"    numcols = [c for c in feat_cardio.columns if c!='date' and pd.api.types.is_numeric_dtype(feat_cardio[c])]\n",
"    seg_stats = feat_cardio.groupby('segment_id')[numcols].agg(['median','mean','std','count'])\n",
"    seg_stats.to_csv(OUTDIR/'segment_stats.csv')\n",
"    display(seg_stats.head())\n"
  ]},
  {"cell_type":"markdown","metadata":{},"source":["## 07 | Label preview (if present)"]},
  {"cell_type":"code","metadata":{},"source":[
"label_cols = [c for c in feat_dailyu.columns if c.lower()=='label'] if not feat_dailyu.empty else []\n",
"if label_cols:\n",
"    df = feat_dailyu[['date', label_cols[0]]].merge(feat_cardio, on='date', how='left')\n",
"    lab = label_cols[0]\n",
"    print('label distribution:\\n', df[lab].value_counts(dropna=False))\n",
"    hrcols = [c for c in feat_cardio.columns if re.search(r'(^|_)hr_mean(_|$)', c)]\n",
"    if hrcols:\n",
"        groups = [g.dropna().values for _, g in df.groupby(lab)[hrcols[0]]]\n",
"        plt.figure(figsize=(6,3))\n",
"        plt.boxplot(groups)\n",
"        plt.title(f'{hrcols[0]} by label'); plt.tight_layout(); plt.savefig(OUTDIR/'box_hr_by_label.png'); plt.show()\n",
"else:\n",
"    print('No label column found; skipping label preview.')\n"
  ]},
  {"cell_type":"markdown","metadata":{},"source":["## 08 | Export consolidated summary (JSON + XLSX)"]},
  {"cell_type":"code","metadata":{},"source":[
"summ = {\n",
"    'pid': PID,\n",
"    'snapshot': SNAP,\n",
"    'manifests': {\n",
"        'extract': (extract_manifest.get('export_sha256','') if extract_manifest else ''),\n",
"        'cardio_outputs': list((cardio_manifest.get('outputs') or {}).keys()) if cardio_manifest else [],\n",
"    },\n",
"    'qc': {'cardio': qc_cardio, 'dailyu': qc_dailyu},\n",
"}\n",
"(OUTDIR/'eda_summary.json').write_text(json.dumps(summ, indent=2), encoding='utf-8')\n",
"\n",
"# XLSX with multiple sheets\n",
"xlsx_path = OUTDIR/'eda_summary.xlsx'\n",
"with pd.ExcelWriter(xlsx_path, engine='openpyxl') as xw:\n",
"    # QC\n",
"    pd.DataFrame([qc_cardio]).to_excel(xw, index=False, sheet_name='qc_cardio')\n",
"    pd.DataFrame([qc_dailyu]).to_excel(xw, index=False, sheet_name='qc_dailyu')\n",
"    # Daily describe\n",
"    if not feat_cardio.empty:\n",
"        num = feat_cardio.drop(columns=['date']).select_dtypes(include=[np.number])\n",
"        num.describe().T.to_excel(xw, sheet_name='daily_describe')\n",
"    # Weekly\n",
"    if not weekly.empty:\n",
"        weekly.to_excel(xw, sheet_name='weekly')\n",
"    # Segment stats\n",
"    if 'seg_stats' in globals() and isinstance(seg_stats, pd.DataFrame) and not seg_stats.empty:\n",
"        seg_stats.to_excel(xw, sheet_name='segment_stats')\n",
"\n",
"print('Wrote:', xlsx_path)\n"
  ]}
 ],
 "metadata": {
  "kernelspec": {"display_name": "Python 3", "language": "python", "name": "python3"},
  "language_info": {"name": "python", "pygments_lexer": "ipython3"}
 },
 "nbformat": 4,
 "nbformat_minor": 5
}

out = Path('notebooks'); out.mkdir(exist_ok=True)
nb = out/'03_eda_cardio_plus.ipynb'
nb.write_text(json.dumps(NB), encoding='utf-8')
print("CREATED:", nb)
